4대 특징

절차지향과 객체지향
절차지향: 프로그램의 순차적 처리를 위주로 설계하는 방법론
객체지향: 서로 상호작용하는 객체를 기본단위로 구성하는 방법론

객체지향 등장배경
물리적인 하드웨어의 발전 빠르게 진행, 소프트웨어 중요성 빠르게 올라감
기존 절차지향의 방식으로는 복잡한 구조에 대한 설계 힘들어짐, 객체지향의 방식이 대안

객체지향의 장단점
장점:	1. 객체단위로 관리하기 때문에 디버깅에 유리
	2. 클래스 단위로 모듈화 시켜 관리하므로 대규모 프로젝트에 유리
	3. 코드의 재사용성 좋음
단점:	1. 설계에 시간이 많이 소비되며 신중해야함

4특징:
캡슐화 , 다형성, 추상화, 상속

캡슐화
객체를 정보와 기능으로 묶는 것을 의미
객체의 내부 정보와 기능을 숨기고, 허용한 정보와 기능만의 엑세스 허용
멤버 변수(필드) : 객체의 정보를 표현
멤버 함수(메서드) : 객체의 기능을 표현
접근제한자: 외부에서 접근이 가능한 멤버변수와 멤버함수를 지정하는 기능
public : 외부에서도 접근 가능
private: 내부에서만 접근 가능
protected: 상속한 클래스에서는 public, 그 외에는 private
	기본 접근제한자는 private

정보은닉:
객체 구성에 있어서 외부에서 사용하기 원하는 기능과 사용하기 원하지 않는 기능을 구분하기 위해 사용
사용자가 객체를 사용하는데 있어 필요한 기능만을 확인하기 위한용도
외부에 의해 영향을 받지 않길 원하는 기능을 감추기 위한 용도

캡슐화 사용의미.1
캡슐화된 클래스는 외부에서 사용하기 위한 인터페이스만을 제공하여 복잡성 제공
캡슐화된 클래스는 내부적으로 어떻게 구현되었는지 몰라도 사용 가능
public을 상단에 두고 private를 하단에 배치하면
다른 누군가가 보아도 상단의 public 만 신경쓰면 됨

캡슐화 사용의미 2
캡슐화된 클래스는 외부에서 원하지않는 사용법으로부터 보호할 수 있어 오용된 사용 방지



상속
부모클래스의 모든 기능을 가지는 자식클래스를 설계하는 방법
is -  a 관계: 부모클래스가 자식클래스를 포함하는 상위개념일경우 상속관계가 적합함
즉, 상속관계가 아님에도 사용하는 경우에 대해 주의
class 자식 : 부모 { }

부모에서 private를 사용하면 자식에서도 사용할 수 없음
이럴때 사용하기 좋은것이 protected
	protected: 상속한 클래스에서는 public, 그 외에는 private
base: 부모클래스(부모에 있는걸 쓸때)
this: 자식클래스(본인것을 쓸때)

: base(매개변수) <- 부모의 생성자 매개변수를 이어받아서 자식을 생성자 만듬 

상속의 진행단계:
	부모를 먼저 만들고 자식을 붙이는 구조

부모의 클래스에 자식 인스턴스를 만들수있음
다른 클래스와 상호작용할때 상속받은 자식들을 상호작용하게하려면 부모 클래스만 상호작용할수 있으면 자식들 또한 모두 해당 클래스와 상호 작용 가능
	업캐스팅: 자식 클래스는 부모클래스 자료형에 (묵시적) 형변환 가능
자식클래스는 부모클래스의 기능에 자식만의 기능을 추가하여 구현가능함
	다운캐스팅: 부모클래스는 자식클래스 자료형으로 명시적 형변환 가능(가능할때만)
	ex) if(monster is Dragon){ 기능 }
		(monster as Dragon)? . 기능
	- 다운캐스팅을 잘 쓰진 않음
	다운캐스팅보단 다형성을 이용


상속을 금지하는법
	sealed 를 붙여 상속을 막을 수 있음



다형성
객체의 속성이나 기능이 상황에 따라 여러가지 형태를 가질 수 있는 성질
다른값의 변수를 넣거나, 함수를 오버라이딩해서 다형성 가능

오버로딩
	함수명이 같아도 매개변수 유무에 따라 다르게 작동함

오버라이딩
	함수명이 같아도
	부모 객체에는 virtual 을 붙여 가상 함수로 만들 수 있음
		가상합수: 부모클래스의 함수 중 자식클래스에 의해 재정의할수있는 함수를 지정
	자식 객체에는 override 를 붙여 자식객체에 대한 자신만의 함수로 사용할 수 있음
		오버라이딩: 부모클래스의 가상함수를 같은 함수이름과 같은 매개변수로 재정의하여 자식만의 반응을 구현


추상화
클래스를 정의할 당시 구체화 시킬 수 없는 기능을 추상적 표현으로 정의
	=>추상클래스
추상메서드 : abstract를 붙이기
	abstract를 넣고 재구현, 즉 오버라이딩을 하지않으면 에러발생
	따라서 무조건 해당 추상메서드에 대한 재구현을 해야만 함 => 개발자의 실수를 줄일 수 있음
재구현: override



